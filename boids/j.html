
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Boids</title>
    <style type="text/css">
        html {
            background-color: #00bad8;
        }

        body {
            margin: 0;
            background: #282c34;
            overflow: hidden;
            margin: 0;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        #cnv {
            position: absolute;
            z-index: 99;
            top: 0;
        }

        #boids {
            position: absolute;
            z-index: 1;
            top: 0;
        }
    </style>
</head>

<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.102.0/examples/js/controls/OrbitControls.js"></script>

    <canvas id="boids" width="150" height="150"></canvas>

</body>
<script>
    var num = 0;
    var boidMesh, scene, camera, renderer, geometry, material;
    let BOX_W = 20;
    let BOX_H = 20;
    let AVOID_POWER = 2;
    const GRID_SIZE = 50;
    const GRID_SIZE2 = GRID_SIZE/2;
    const numBoids = 100;
    const visualRange = 50;
    var boids = [];
    var boids3D = [];
    const speedLimit = 0.1;

    function startthree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = 'cnv';
        document.body.appendChild(renderer.domElement);

        geometry = new THREE.BoxGeometry(0.2, 3, 0.2);
        material = new THREE.MeshBasicMaterial({
            color: "#000000"
        });
        boidMesh = new THREE.Mesh(geometry, material);
        scene.add(boidMesh);
        boidMesh.visible = false;

        camera.position.z = 100;
        camera.position.y = 100;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.maxDistance = 150;
        controls.minDistance = 1;
        controls.maxPolarAngle = Math.PI * 0.49;

        var size = GRID_SIZE;
        var divisions = 1;
        var gridHelper = new THREE.GridHelper(size, divisions);
        scene.add(gridHelper);

    }


    function animate() {
        renderer.render(scene, camera);
        animationLoop()
        requestAnimationFrame(animate);
    };

    function initBoids() {
        for (var i = 0; i < numBoids; i += 1) {
            var boidclone = boidMesh.clone();
            boidclone.visible = true;
            scene.add(boidclone);
            boids3D.push(boidclone)
            //
            boids[boids.length] = {
                x: Math.random() * BOX_W,
                y: Math.random() * BOX_H,
                dx: Math.random() * 10 - 5,
                dy: Math.random() * 10 - 5
            };
        }
    }


    function distance(boid1, boid2) {
        return Math.sqrt(
            (boid1.x - boid2.x) * (boid1.x - boid2.x) +
            (boid1.y - boid2.y) * (boid1.y - boid2.y),
        );
    }


    function keepWithinBounds(boid) {
        const margin = 200;
        const turnFactor = 1;

        if (boid.x < margin) {
            boid.dx += turnFactor;
        }
        if (boid.x > BOX_W - margin) {
            boid.dx -= turnFactor
        }
        if (boid.y < margin) {
            boid.dy += turnFactor;
        }
        if (boid.y > BOX_H - margin) {
            boid.dy -= turnFactor;
        }
    }

    function flyTowardsCenter(boid) {
        const centeringFactor = 0.005; // adjust velocity by this %

        let centerX = 0;
        let centerY = 0;
        let numNeighbors = 0;

        for (let otherBoid of boids) {
            if (distance(boid, otherBoid) < visualRange) {
                centerX += otherBoid.x;
                centerY += otherBoid.y;
                numNeighbors += 1;
            }
        }

        if (numNeighbors) {
            centerX = centerX / numNeighbors;
            centerY = centerY / numNeighbors;

            boid.dx += (centerX - boid.x) * centeringFactor;
            boid.dy += (centerY - boid.y) * centeringFactor;
        }
    }

    // Move away from other boids that are too close to avoid colliding
    function avoidOthers(boid) {
        const minDistance = AVOID_POWER ?? 10; // The distance to stay away from other boids
        const avoidFactor = 0.05; // Adjust velocity by this %
        let moveX = 0;
        let moveY = 0;
        for (let otherBoid of boids) {
            if (otherBoid !== boid) {
                if (distance(boid, otherBoid) < minDistance) {
                    moveX += boid.x - otherBoid.x;
                    moveY += boid.y - otherBoid.y;
                }
            }
        }

        boid.dx += moveX * avoidFactor;
        boid.dy += moveY * avoidFactor;
    }

    function matchVelocity(boid) {
        const matchingFactor = 0.05; // Adjust by this % of average velocity

        let avgDX = 0;
        let avgDY = 0;
        let numNeighbors = 0;

        for (let otherBoid of boids) {
            if (distance(boid, otherBoid) < visualRange) {
                avgDX += otherBoid.dx;
                avgDY += otherBoid.dy;
                numNeighbors += 1;
            }
        }

        if (numNeighbors) {
            avgDX = avgDX / numNeighbors;
            avgDY = avgDY / numNeighbors;

            boid.dx += (avgDX - boid.dx) * matchingFactor;
            boid.dy += (avgDY - boid.dy) * matchingFactor;
        }
    }

    // Speed will naturally vary in flocking behavior, but real animals can't go
    // arbitrarily fast.
    function limitSpeed(boid) {
        const speed = Math.sqrt(boid.dx * boid.dx + boid.dy * boid.dy);
        if (speed > speedLimit) {
            boid.dx = (boid.dx / speed) * speedLimit;
            boid.dy = (boid.dy / speed) * speedLimit;
        }
    }

    const DRAW_TRAIL = false;

    function isNextStepOOB(boid) {
        let nextIsOOB = false;

        const nx = boid.x + (boid.dx*2);
        const ny = boid.y + (boid.dy*2);

        if (nx < -GRID_SIZE2) {
            nextIsOOB = true;
        }
        if (nx > GRID_SIZE2) {
            nextIsOOB = true;
        }
        if (ny < -GRID_SIZE2) {
            nextIsOOB = true;
        }
        if (ny > GRID_SIZE2) {
            nextIsOOB = true;
        }

        return nextIsOOB;
    }

    // Main animation loop
    function animationLoop() {
        num++;
        AVOID_POWER = 3+(Math.sin(num/20)*2)
        // Update each boid
        for (let boid of boids) {
            // Update the velocities according to each rule
            flyTowardsCenter(boid);
            avoidOthers(boid);
            matchVelocity(boid);
            limitSpeed(boid);
            keepWithinBounds(boid);

            const nextStepWasOOB = isNextStepOOB(boid);

            // Update the position based on the current velocity
            if(!nextStepWasOOB) {
                boid.x += boid.dx;
                boid.y += boid.dy;
            } else {
                boid.dx *= -1;
                boid.dy *= -1;
            }
        }

        // 
        for (var i = 0; i < boids3D.length; i++) {
            boids3D[i].position.x = boids[i].x;
            boids3D[i].position.z = boids[i].y;
        }

    }

    // handle window resize
    window.addEventListener('resize', function () {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }, false)



    // start
    startthree();
    initBoids();
    animate();
</script>


</html>