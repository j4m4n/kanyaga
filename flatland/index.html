<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Flatland</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <style>
            @font-face {
                font-family: "prstartk";
                src:
                    url("fonts/prstartk-webfont.woff2") format("woff2"),
                    url("fonts/prstartk-webfont.woff") format("woff");
                font-weight: normal;
                font-style: normal;
            }

            html,
            body {
                margin: 0;
                height: 100%;
                overflow: hidden;
                background: #ff0000;
                color: #46261d;
                user-select: none;
                font-family: "prstartk";
            }
            canvas {
                image-rendering: pixelated;
            }

            #colcanvas,
            #hitcanvas {
                position: absolute;
                top: -100px;
                left: -100px;
                width: 512px;
                height: 512px;
                background: #222;
                transform: scale(0.5);
            }
            .on #colcanvas,
            .off #hitcanvas {
                display: block;
            }
            .off #colcanvas,
            .on #hitcanvas {
                display: none;
            }

            #hud {
                position: absolute;
                top: 0;
                left: 0;
                z-index: 99;
                padding: 8px;
                background: rgba(0, 0, 0, 0.5);
                color: #fff;
                font-family: "prstartk";
            }
            #btn {
                background: transparent;
                border: none;
                color: #fff;
                padding: 12px;
                cursor: pointer;
                outline: none;
                font-family: "prstartk";
            }
            #btn:active {
                color: #ffff00;
            }
            #btn.on {
                background: #ff0000;
            }
        </style>
    </head>
    <body class="on">
        <div id="hud">
            <button id="btn">x</button>
            <p id="xvar">xvar</p>
        </div>

        <canvas id="colcanvas" width="512" height="512"></canvas>
        <canvas id="hitcanvas" width="512" height="512"></canvas>

        <div id="threecnv"></div>

        <script src="js/three.min.js"></script>
        <script src="js/nipplejs.min.js"></script>

        <script type="module">
            (() => {
                const CANVAS_SIZE = 512;
                const HALF_CANVAS = CANVAS_SIZE / 2;
                const PLAYER_MAX_SPEED = 1;
                const JOYSTICK_MAX_SPEED = 1;

                const hudBtn = document.getElementById("btn");
                const hudInfo = document.getElementById("xvar");

                const colCanvas = document.getElementById("colcanvas");
                const colCtx = colCanvas.getContext("2d");

                const hitCanvas = document.getElementById("hitcanvas");
                const hitCtx = hitCanvas.getContext("2d", {
                    willReadFrequently: true,
                });

                hudBtn.addEventListener("click", () => {
                    document.body.classList.toggle("on");
                    document.body.classList.toggle("off");
                    hudBtn.classList.toggle("on");
                });

                const keyboard = {
                    _pressed: {},
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    isDown(key) {
                        return this._pressed[key];
                    },
                    onKeyDown(e) {
                        this._pressed[e.keyCode] = true;
                    },
                    onKeyUp(e) {
                        delete this._pressed[e.keyCode];
                    },
                };
                window.addEventListener("keydown", (e) =>
                    keyboard.onKeyDown(e),
                );
                window.addEventListener("keyup", (e) => keyboard.onKeyUp(e));

                const limitVelocity = (vx, vy, max) => {
                    const len = Math.hypot(vx, vy);
                    if (!len) return { vx: 0, vy: 0 };
                    const scale = Math.min(len, max) / len;
                    return { vx: vx * scale, vy: vy * scale };
                };

                const aliasedCircle = (ctx, xc, yc, r) => {
                    let x = r,
                        y = 0,
                        cd = 0;
                    ctx.rect(xc - x, yc, r << 1, 1);
                    while (x > y) {
                        cd -= --x - ++y;
                        if (cd < 0) cd += x++;
                        ctx.rect(xc - y, yc - x, y << 1, 1);
                        ctx.rect(xc - x, yc - y, x << 1, 1);
                        ctx.rect(xc - x, yc + y, x << 1, 1);
                        ctx.rect(xc - y, yc + x, y << 1, 1);
                    }
                };

                hitCtx.fillStyle = "#fff";
                hitCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                hitCtx.fillStyle = "#000";
                hitCtx.beginPath();
                aliasedCircle(
                    hitCtx,
                    HALF_CANVAS,
                    HALF_CANVAS,
                    HALF_CANVAS - 2,
                );
                hitCtx.fill();

                colCtx.fillStyle = "#e60087";
                colCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                const imgBase = new Image();
                const imgTex = new Image();

                const loadImg = (img, src, onload) => {
                    return new Promise((res, rej) => {
                        img.onload = () => {
                            onload();
                            res();
                        };
                        img.onerror = rej;
                        img.src = src;
                    });
                };

                Promise.all([
                    loadImg(imgBase, "level-1base.png", () =>
                        hitCtx.drawImage(imgBase, 0, 0),
                    ),
                    loadImg(imgTex, "level-col.png", () =>
                        colCtx.drawImage(imgTex, 0, 0),
                    ),
                ])
                    .then(() => {
                        initThree();
                        animate();
                    })
                    .catch((err) =>
                        console.error("Failed to load level images", err),
                    );

                let scene, camera, renderer, player, cursor, colPlane;

                const initThree = () => {
                    renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                    });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    document.body.appendChild(renderer.domElement);

                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(
                        75,
                        window.innerWidth / window.innerHeight,
                        1,
                        2000,
                    );
                    camera.position.set(0, 50, 50);
                    camera.lookAt(0, 0, 0);

                    const amb = new THREE.AmbientLight(0xeeeeee, 0.7);
                    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
                    dir.position.set(0, 50, 0);
                    dir.castShadow = true;
                    dir.shadow.mapSize.set(32, 32);
                    dir.shadow.camera.near = 0.5;
                    dir.shadow.camera.far = 500;
                    scene.add(amb, dir);

                    const tex = new THREE.CanvasTexture(colCanvas);
                    tex.magFilter = tex.minFilter = THREE.NearestFilter;

                    const geometry = new THREE.PlaneGeometry(
                        512,
                        512,
                        512,
                        512,
                    );
                    const material = new THREE.MeshStandardMaterial({
                        map: tex,
                        metalness: 0.2,
                        displacementMap: new THREE.TextureLoader().load(
                            "level3D.png",
                        ),
                        displacementScale: 20,
                    });
                    colPlane = new THREE.Mesh(geometry, material);
                    colPlane.rotation.x = -Math.PI / 2;
                    colPlane.position.y = -10;
                    colPlane.castShadow = true;
                    colPlane.receiveShadow = true;
                    scene.add(colPlane);

                    player = new THREE.Group();
                    scene.add(player);

                    const headGeo = new THREE.SphereGeometry(3, 12, 12);
                    const headMat = new THREE.MeshStandardMaterial({
                        color: 0xee0000,
                    });
                    const head = new THREE.Mesh(headGeo, headMat);
                    head.position.set(0, 10, 0);
                    head.castShadow = true;
                    player.add(head);

                    const arrowGeo = new THREE.CircleGeometry(1, 3);
                    const arrowMat = new THREE.MeshBasicMaterial({
                        color: 0xffff00,
                    });
                    const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                    arrow.rotation.set(-Math.PI / 2, 0, -Math.PI / 6);
                    arrow.position.set(0, 1, -5);
                    player.add(arrow);

                    cursor = new THREE.Group();
                    scene.add(cursor);

                    const target = new THREE.Group();
                    target.position.y = 1;
                    cursor.add(target);
                    player.userData.target = target;

                    window.addEventListener("resize", onResize);
                };

                const onResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };

                const hero = {
                    allowMove: true,
                    moving: false,
                    maxSpeed: PLAYER_MAX_SPEED,
                    posX: 0,
                    posZ: 0,
                    vx: 0,
                    vy: 0,
                    lastPixel: 0,
                };

                const updateloop = () => {
                    if (hero.allowMove) {
                        if (keyboard.isDown(keyboard.LEFT))
                            cursor.position.x -= hero.maxSpeed;
                        if (keyboard.isDown(keyboard.RIGHT))
                            cursor.position.x += hero.maxSpeed;
                        if (keyboard.isDown(keyboard.UP))
                            cursor.position.z -= hero.maxSpeed;
                        if (keyboard.isDown(keyboard.DOWN))
                            cursor.position.z += hero.maxSpeed;
                    }

                    if (hero.moving) {
                        cursor.position.x += hero.vx;
                        cursor.position.z += hero.vy;
                    }

                    player.position.x +=
                        (cursor.position.x - player.position.x) * 0.3;
                    player.position.z +=
                        (cursor.position.z - player.position.z) * 0.3;

                    player.lookAt(
                        player.userData.target.position.x,
                        0,
                        player.userData.target.position.z,
                    );

                    const u = HALF_CANVAS + Math.floor(cursor.position.x);
                    const v = HALF_CANVAS + Math.floor(cursor.position.z);
                    const pixel = hitCtx.getImageData(u, v, 1, 1).data[0];

                    if (pixel > 254) {
                        cursor.position.x = hero.posX;
                        cursor.position.z = hero.posZ;
                        hero.allowMove = false;
                    } else {
                        hero.posX = cursor.position.x;
                        hero.posZ = cursor.position.z;
                        hero.allowMove = true;
                    }

                    if (hero.lastPixel !== pixel) {
                        if (pixel > 99) {
                        } else {
                            hudInfo.textContent = pixel;
                        }
                        hero.lastPixel = pixel;
                    }

                    scene.position.set(
                        -player.position.x,
                        0,
                        -player.position.z,
                    );
                };

                const initJoystick = () => {
                    const stick = nipplejs.create({
                        mode: "dynamic",
                        dataOnly: true,
                        zone: document.body,
                    });

                    stick.on("move", (e, data) => {
                        const vx = data.force * Math.cos(data.angle.radian);
                        const vy = -data.force * Math.sin(data.angle.radian);
                        const limited = limitVelocity(
                            vx,
                            vy,
                            JOYSTICK_MAX_SPEED,
                        );
                        hero.vx = limited.vx;
                        hero.vy = limited.vy;
                        hero.moving = true;

                        const angle =
                            Math.atan2(hero.vy, hero.vx) + Math.PI * 0.5;
                        player.rotation.y = -angle;
                    });

                    stick.on("end", () => {
                        hero.moving = false;
                        hero.vx = hero.vy = 0;
                    });
                };

                const animate = () => {
                    requestAnimationFrame(animate);
                    updateloop();
                    renderer.render(scene, camera);
                };

                const startGame = () => {
                    initJoystick();
                };

                Promise.all([])
                    .then(startGame)
                    .catch(() => {});
            })();
        </script>
    </body>
</html>
